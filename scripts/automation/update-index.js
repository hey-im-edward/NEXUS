#!/usr/bin/env node

/**
 * Auto-generate index.md from memory bank files
 * Updates file summaries and last updated dates
 */

const fs = require('fs');
const path = require('path');

const MEMORY_BANK_PATH = path.join(__dirname, '../../memory-bank');

const FILE_METADATA = {
  'project-brief.md': {
    purpose: 'Ph·∫°m vi + m·ª•c ti√™u c·ªët l√µi',
    sections: 'Objective, Core Features, Non-Goals, Success Metrics',
    frequency: 'Hi·∫øm (khi pivot)'
  },
  'product-context.md': {
    purpose: 'V·∫•n ƒë·ªÅ, user goals, UX ƒë·ªãnh h∆∞·ªõng',
    sections: 'Problem, Target Users, User Stories, Experience Notes',
    frequency: 'Khi business thay ƒë·ªïi'
  },
  'system-patterns.md': {
    purpose: 'Ki·∫øn tr√∫c, pattern, layer, flow',
    sections: 'Layer Diagram, Data Flow, Key Patterns, Integration Points',
    frequency: 'Khi pattern m·ªõi ·ªïn ƒë·ªãnh'
  },
  'tech-context.md': {
    purpose: 'Stack, constraints, deps, env',
    sections: 'Stack Table, Version Requirements, Env Setup, External Services',
    frequency: 'Khi th√™m/lo·∫°i c√¥ng ngh·ªá'
  },
  'active-context.md': {
    purpose: 'C√¥ng vi·ªác hi·ªán t·∫°i, sessions, next steps',
    sections: 'Current Focus, Recent Sessions, Next Steps, Open Questions',
    frequency: 'M·ªói phi√™n'
  },
  'progress.md': {
    purpose: 'Ti·∫øn ƒë·ªô: Done / In progress / Blocked / Risks',
    sections: 'Task Status Table, Weekly Plans, Risks',
    frequency: '1‚Äì3 ng√†y'
  },
  'decisions/recent.md': {
    purpose: 'Quy·∫øt ƒë·ªãnh m·ªõi (ng·∫Øn)',
    sections: 'Reverse chronological decisions with status',
    frequency: 'Khi ph√°t sinh'
  },
  'glossary.md': {
    purpose: 'Thu·∫≠t ng·ªØ domain',
    sections: 'Domain terminology definitions',
    frequency: 'Khi domain m·ªü r·ªông'
  }
};

class IndexUpdater {
  constructor() {
    this.currentDate = new Date().toISOString().split('T')[0];
  }

  // Get file last modified date
  getFileLastModified(filePath) {
    try {
      const stats = fs.statSync(filePath);
      return stats.mtime.toISOString().split('T')[0];
    } catch (error) {
      return 'Unknown';
    }
  }

  // Read first few lines of file to extract title/summary
  getFileSummary(filePath) {
    try {
      const content = fs.readFileSync(filePath, 'utf8');
      const lines = content.split('\n').slice(0, 5);

      // Extract title (first # line)
      const titleMatch = content.match(/^#\s+(.+)$/m);
      const title = titleMatch ? titleMatch[1] : 'No title found';

      // Extract brief description (first paragraph)
      const description = lines.find(line => line.trim() && !line.startsWith('#')) || '';

      return {
        title: title.substring(0, 50) + (title.length > 50 ? '...' : ''),
        description: description.substring(0, 80) + (description.length > 80 ? '...' : '')
      };
    } catch (error) {
      return { title: 'Error reading file', description: error.message };
    }
  }

  // Generate index content
  generateIndexContent() {
    const files = Object.keys(FILE_METADATA);

    let content = `# Memory Bank Index

## File Summary (Last Updated: ${this.currentDate})

| File | Purpose | Key Sections | Last Updated |
|------|---------|--------------|--------------|
`;

    files.forEach(file => {
      const metadata = FILE_METADATA[file];
      const filePath = path.join(MEMORY_BANK_PATH, file);
      const lastModified = this.getFileLastModified(filePath);
      const summary = this.getFileSummary(filePath);

      content += `| [${file}](${file}) | ${metadata.purpose} | ${metadata.sections} | ${lastModified} |\n`;
    });

    content += `
## Quick Access

**Start Here**: [project-brief.md](project-brief.md) ‚Üí scope c·ªët l√µi
**Current Work**: [active-context.md](active-context.md) ‚Üí tr·∫°ng th√°i hi·ªán h√†nh
**Architecture**: [system-patterns.md](system-patterns.md) ‚Üí c·∫•u tr√∫c h·ªá th·ªëng
**Tech Stack**: [tech-context.md](tech-context.md) ‚Üí c√¥ng ngh·ªá v√† r√†ng bu·ªôc

---
*Last Updated: ${this.currentDate} - Auto-generated by update-index.js*
`;

    return content;
  }

  // Update index.md
  updateIndex() {
    const indexPath = path.join(MEMORY_BANK_PATH, 'index.md');
    const newContent = this.generateIndexContent();

    try {
      fs.writeFileSync(indexPath, newContent);
      console.log(`‚úÖ Updated index.md with ${this.currentDate} timestamp`);
      return true;
    } catch (error) {
      console.error('‚ùå Failed to update index.md:', error.message);
      return false;
    }
  }

  // Main execution
  run() {
    console.log('üîÑ Auto-updating Memory Bank Index...');

    const success = this.updateIndex();

    if (success) {
      console.log('‚úÖ Index update completed successfully');
    } else {
      console.log('‚ùå Index update failed');
      process.exit(1);
    }
  }
}

// Run if called directly
if (require.main === module) {
  const updater = new IndexUpdater();
  updater.run();
}

module.exports = IndexUpdater;
